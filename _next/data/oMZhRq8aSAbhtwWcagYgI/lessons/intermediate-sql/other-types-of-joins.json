{"pageProps":{"post":{"attributes":{},"html":"<p>We looked at several way of doing joins in the last section by using the <code>JOIN</code> keyword. One key thing about that is we were doing <code>INNER JOIN</code>s. If you don&#39;t specifiy what type of join to do, it implicitly an INNER JOIN. In practice it didn&#39;t matter because our queries have matched up 1:1:</p>\n<pre><code class=\"language-sql\">SELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nLIMIT\n    5;\n</code></pre>\n<blockquote>\n<p><code>INNER JOIN</code> or just <code>JOIN</code> are the same thing.</p>\n</blockquote>\n<p><a href=\"https://commons.wikimedia.org/wiki/File:SQL_Joins.svg\"><img src=\"/images/SQL_Joins.png\" alt=\"diagram of SQL joins\"></a></p>\n<p>Our INNER JOIN is giving us the inner section on the Venn Diagram between the two tables. Let&#39;s say that we have an artist in the artist table that we don&#39;t have any albums for. If we just</p>\n<pre><code class=\"language-sql\">SELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = &#39;Snow Patrol&#39;;\n\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = &#39;Snow Patrol&#39;;\n</code></pre>\n<p>Notice the first query doesn&#39;t give us any results. That&#39;s because it&#39;s an inner join – it will only give us things that rows in <em>both</em> tables. Now if we run the second query, it&#39;ll give anything that&#39;s in the inner part (which is nothing, as we just saw) <em>and</em> it will give us anything that <em>just</em> exists in the Artist Table (the &quot;right&quot; table in this case.)</p>\n<blockquote>\n<p>LEFT refers to the FROM clause table, RIGHT refers to what comes from the JOIN.</p>\n</blockquote>\n<p>What if we wanted to see all artists without an album in the album table?</p>\n<pre><code class=\"language-sql\">SELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT OUTER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId;\n</code></pre>\n<p>That OUTER part means <em>only</em> take things that don&#39;t have anything in the Album table, so it will only give us artists with no albums in the albums table.</p>\n<h2>NATURAL JOIN</h2>\n<pre><code class=\"language-sql\">SELECT\n    B.Name, A.Title\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nLIMIT\n    5;\n\nSELECT\n    B.Name, A.Title, C.Name\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nNATURAL JOIN\n    Track C\nLIMIT\n    5;\n</code></pre>\n<p>I don&#39;t really like NATURAL JOIN but I thought I&#39;d mention it because you&#39;ll see it from time to time. By saying NATURAL JOIN in this case, we&#39;re saying &quot;hey, I have columns in both tables that are named the same thing. Using that, join these tables.&quot;</p>\n<p>It might seem convenient (and if you structure your tables well, like Chinook is, it&#39;s easy) but it&#39;s so implicit. I don&#39;t like magic code and this feels magic and brittle. If you renamed a column or drop it or anything like that, you can break your queries or, even worse, get wrong data back. I&#39;d say steer clear.</p>\n","markdown":"We looked at several way of doing joins in the last section by using the `JOIN` keyword. One key thing about that is we were doing `INNER JOIN`s. If you don't specifiy what type of join to do, it implicitly an INNER JOIN. In practice it didn't matter because our queries have matched up 1:1:\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nLIMIT\n    5;\n```\n\n> `INNER JOIN` or just `JOIN` are the same thing.\n\n[![diagram of SQL joins](/images/SQL_Joins.png)](https://commons.wikimedia.org/wiki/File:SQL_Joins.svg)\n\nOur INNER JOIN is giving us the inner section on the Venn Diagram between the two tables. Let's say that we have an artist in the artist table that we don't have any albums for. If we just\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = 'Snow Patrol';\n\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = 'Snow Patrol';\n```\n\nNotice the first query doesn't give us any results. That's because it's an inner join – it will only give us things that rows in _both_ tables. Now if we run the second query, it'll give anything that's in the inner part (which is nothing, as we just saw) _and_ it will give us anything that _just_ exists in the Artist Table (the \"right\" table in this case.)\n\n> LEFT refers to the FROM clause table, RIGHT refers to what comes from the JOIN.\n\nWhat if we wanted to see all artists without an album in the album table?\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT OUTER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId;\n```\n\nThat OUTER part means _only_ take things that don't have anything in the Album table, so it will only give us artists with no albums in the albums table.\n\n## NATURAL JOIN\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nLIMIT\n    5;\n\nSELECT\n    B.Name, A.Title, C.Name\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nNATURAL JOIN\n    Track C\nLIMIT\n    5;\n```\n\nI don't really like NATURAL JOIN but I thought I'd mention it because you'll see it from time to time. By saying NATURAL JOIN in this case, we're saying \"hey, I have columns in both tables that are named the same thing. Using that, join these tables.\"\n\nIt might seem convenient (and if you structure your tables well, like Chinook is, it's easy) but it's so implicit. I don't like magic code and this feels magic and brittle. If you renamed a column or drop it or anything like that, you can break your queries or, even worse, get wrong data back. I'd say steer clear.\n","slug":"other-types-of-joins","title":"Other Types of Joins","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/B-other-types-of-joins.md","nextSlug":"/lessons/intermediate-sql/foreign-keys","prevSlug":"/lessons/intermediate-sql/relational-data"}},"__N_SSG":true}